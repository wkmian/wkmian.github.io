{"meta":{"title":"wkmian的博客","subtitle":"IT界的小学生","description":"成长之路","author":"wkmian","url":"https://wkmian.github.io"},"pages":[{"title":"分类","date":"2018-06-26T07:05:18.000Z","updated":"2018-06-26T07:27:38.418Z","comments":true,"path":"categories/index.html","permalink":"https://wkmian.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-06-26T07:14:24.000Z","updated":"2018-06-26T07:27:38.399Z","comments":true,"path":"tags/index.html","permalink":"https://wkmian.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java编写规范","slug":"java/java编写规范","date":"2018-09-19T05:01:56.000Z","updated":"2018-09-19T09:03:59.542Z","comments":true,"path":"2018/09/19/java-writing-specification/","link":"","permalink":"https://wkmian.github.io/2018/09/19/java-writing-specification/","excerpt":"","text":"更新于 2018年9月19日 总结一些在java里面的一些编写规范 使用缓存缓存数据的时候,尽量不缓存null，而使用其他的类型代替null以区分是没有找到数据还是缓存的数据是null","categories":[{"name":"编程规范","slug":"编程规范","permalink":"https://wkmian.github.io/categories/编程规范/"}],"tags":[{"name":"java","slug":"java","permalink":"https://wkmian.github.io/tags/java/"},{"name":"规范","slug":"规范","permalink":"https://wkmian.github.io/tags/规范/"}]},{"title":"JDK1.8更新特性","slug":"java/JDK1-8更新特性","date":"2018-09-10T01:52:18.000Z","updated":"2018-09-19T09:03:59.542Z","comments":true,"path":"2018/09/10/jdk18-update-feature/","link":"","permalink":"https://wkmian.github.io/2018/09/10/jdk18-update-feature/","excerpt":"","text":"更新于 2018年9月19日 JDK 1.8 于2014-03-08发布主要新特性 Lambda 表达式 方法引用 默认方法 Stream API 函数式编程API Date Time API 加强对日期与时间的处理 Optional Nashorn JavaScript引擎 新工具 Lambda语法如下12(parameters) -&gt; expression(parameters) -&gt; &#123;statements;&#125; lambda表达式重要特征 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值 可选参数圆括号：一个参数无需定义圆括号，但多个参数或无参数需要定义圆括号 可选大括号：如果主体包含一个语句，无需定义大括号 可选return关键字：如果主体只有一个表达式无需声明return关键字，如果定义大括号则需要声明return关键字 lambda表达式使用限制 预定义使用了 @Functional 注释的函数式接口，自带一个抽象函数的方法 SAM（Single Abstract Method 单个抽象方法）类型 lambda变量作用域 在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。 lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义） 方法引用方法引用通过方法的名字来指向一个方法。 方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 方法引用使用一对冒号 :: 。 函数式接口函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口都可以写成lambda表达式，结合lambda使用更方便。 接口默认方法接口可以定义一个默认方法和静态方法 默认方法，让接口可以拥有一个默认实现，防止新增不兼容。感觉这个方法的出现仅仅是为了新JDK兼容而出现了，个人认为在一定程度上破坏了接口的定义。也许它会有更好的用处。123456789public interface Vehicle&#123; default void print()&#123; System.out.println(&quot;我是默认方法&quot;); &#125; static void say()&#123; System.out.println(&quot;我是静态方法&quot;); &#125;&#125; 当多实现接口的时候会出现默认接口冲突1234567public class C implements A,B&#123; @Override public void print()&#123; //重写或者调用接口中的其中一个 A.super.print(); &#125;&#125; Stream API体验一个流式编程编写的统计所有偶数之和代码123List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,10);int count = list.stream().filter(n-&gt; (n&amp;1)==0).mapToInt(i-&gt;i).sum();System.out.println(count); map:在Stream中的意识是映射，就是将当前的value处理成另一个值flatMap：将多个流合成一个流处理 Optional 类可以让java编写时对null的处理方式以流式+lambda的形式更好的展现出来 之前判断null的例子123456789if(null != user)&#123; Address address = user.getAddress(); if(null != address)&#123; Country country = address.Country(); if(null != country)&#123; //TODO &#125; &#125;&#125; ifPresent1234Optional&lt;User&gt; userOptional = Optional.ifNullable(getUser());if(userOptional.isPresent())&#123; //TODO&#125; 虽然ifPresent可以判断value是否存在，但这样的写法没有体现Optional的强大之处，Optional的强大之处在流式编程。下面是利用Optional流式编程的例子12345String result = Optional.ofNullalbe(user) .map(user -&gt; user.getAddress() ) .map(address -&gt; address.getCountry() ) .map(country -&gt; country.getName() ) .orElse(&quot;没有国家&quot;); orElse() orElseGet()对比1234567public T orElse(T other) &#123; return value != null ? value : other;&#125;public T orElseGet(Supplier&lt;? extends T&gt; other) &#123; return value != null ? value : other.get();&#125; 从源代码实现中可以返现，orElseGet只有在对象为空的时候才会去调用other.get()方法执行获取对象操作，Optional.ofNullable(user).orElse(new User()); 这样的写法无论user是否存在都会执行new User(); Nashorn JavaScript从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。 与先前的Rhino实现相比，这带来了2到10倍的性能提升。 jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。 12345$ jjsjjs&gt; print(&quot;Hello, World!&quot;)Hello, World!jjs&gt; quit()&gt;&gt; 日期时间APILocalDate : 本地日期 LocalTime : 本地时间 LocalDateTime : 本地日期时间 ChronoUnit ： 时间单位 Duration ： 时间段 内部记录时间1234567891011121314public final class Duration implements TemporalAmount, Comparable&lt;Duration&gt;, Serializable &#123; /** * The number of seconds in the duration. */ private final long seconds; /** * The number of nanoseconds in the duration, expressed as a fraction of the * number of seconds. This is always positive, and never exceeds 999,999,999. */ private final int nanos;&#125; Temporal.plus() Temporal.minus() 增加或者删除一段时间 isLeapYear() 判断是否是闰年 Period.between(LocalDate start ,LocalDate end) 比较两个时间的差值，返回一个Period对象 Base64在JDK1.8中,Base64编码加入到Java类库 Base64提供了三种编码方式 基本 输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。 url 输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。 MIME 输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\\r’并跟随’\\n’作为分割。编码输出最后没有行分割。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://wkmian.github.io/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"https://wkmian.github.io/tags/jdk/"}]},{"title":"JDK版本更新特性","slug":"java/JDK版本更新特性","date":"2018-09-10T01:46:10.000Z","updated":"2018-09-19T09:03:59.744Z","comments":true,"path":"2018/09/10/jdk-version-update-feature/","link":"","permalink":"https://wkmian.github.io/2018/09/10/jdk-version-update-feature/","excerpt":"","text":"","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://wkmian.github.io/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"https://wkmian.github.io/tags/jdk/"}]},{"title":"红黑树","slug":"算法/红黑树","date":"2018-08-08T06:13:27.000Z","updated":"2018-09-19T09:04:37.231Z","comments":true,"path":"2018/08/08/red-black-tree/","link":"","permalink":"https://wkmian.github.io/2018/08/08/red-black-tree/","excerpt":"","text":"红黑树是平衡二叉树的一种","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://wkmian.github.io/tags/算法/"}]},{"title":"mysql","slug":"mysql","date":"2018-07-25T07:04:11.000Z","updated":"2018-08-29T06:41:57.647Z","comments":true,"path":"2018/07/25/mysql/","link":"","permalink":"https://wkmian.github.io/2018/07/25/mysql/","excerpt":"","text":"查看事务运行情况（行锁）1select * from information_schema.innodb_trx\\G trx_mysql_thread_id 为线程id 可以使用kill杀死线程","categories":[{"name":"数据库","slug":"数据库","permalink":"https://wkmian.github.io/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://wkmian.github.io/tags/mysql/"}]},{"title":"二进制运算","slug":"编程/二进制运算","date":"2018-07-19T01:56:09.000Z","updated":"2018-09-19T09:05:22.188Z","comments":true,"path":"2018/07/19/binary-operation/","link":"","permalink":"https://wkmian.github.io/2018/07/19/binary-operation/","excerpt":"","text":"二进制运算 &amp; 与运算n位都是1得1，否则得0 性质：1X &amp; X = X | 或运算n位都是0得0，否则得1 ^ 异或预算n位相同得0，否则得1 性质：123456789100 ^ 0 = 00 ^ 1 = 11 ^ 1 = 01 ^ 0 = 1且有X ^ X = 0X ^ 0 = X根据这两个性质可以得出，1.相同位上存在偶数个1得0,奇数个1得1,0可以不参与计算2.异或满足结合律和交换律 ~ 非运算（一元运算符）0变1,1变0 &lt;&lt; 左移向左移动，低位补0 >> 右移向右移动n位，最高位补符号位（正数补0，负数补1），其他位补0 >>> 无符号右移同右移，但最高位统一补0 位移注意点：位移时如果位移位数大于数据类型长度，会先将位移位数取模计算，否则将产生无意义元算 源码，反码，补码正整数的原码，反码，补码都是本身原码：原码就是符号位加上真值的绝对值。反码：保留符号位，其余取反补码：反码+1 二进制的一些简单应用： X &gt;&gt; 1 整除2，X &gt;&gt; 2 整除4 X &amp; (X-1) 可以去除二进制表示中最后一个1","categories":[{"name":"编程","slug":"编程","permalink":"https://wkmian.github.io/categories/编程/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wkmian.github.io/tags/算法/"},{"name":"二进制","slug":"二进制","permalink":"https://wkmian.github.io/tags/二进制/"}]},{"title":"算法题总结","slug":"算法/算法题总结","date":"2018-07-17T06:22:55.000Z","updated":"2018-09-19T09:04:37.116Z","comments":true,"path":"2018/07/17/summary-of-algorithm-questions/","link":"","permalink":"https://wkmian.github.io/2018/07/17/summary-of-algorithm-questions/","excerpt":"","text":"有15个瓶子，其中最多有一瓶有毒，现在有四只老鼠，喝了有毒的水之后，第二天就会死。如何在第二天就可以判断出哪个瓶子有毒。提示：二进制","categories":[{"name":"编程","slug":"编程","permalink":"https://wkmian.github.io/categories/编程/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wkmian.github.io/tags/算法/"}]},{"title":"log4j2使用总结","slug":"java/log4j2使用总结","date":"2018-07-17T01:44:10.000Z","updated":"2018-09-19T09:04:57.304Z","comments":true,"path":"2018/07/17/summary-of-log4j2-usage/","link":"","permalink":"https://wkmian.github.io/2018/07/17/summary-of-log4j2-usage/","excerpt":"","text":"lo4j2的总结log4j2不同于log4j","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://wkmian.github.io/tags/java/"},{"name":"log","slug":"log","permalink":"https://wkmian.github.io/tags/log/"},{"name":"log4j2","slug":"log4j2","permalink":"https://wkmian.github.io/tags/log4j2/"}]},{"title":"java定时器Timer","slug":"java/java定时器Timer","date":"2018-07-12T07:51:14.000Z","updated":"2018-09-19T09:03:59.809Z","comments":true,"path":"2018/07/12/java-timer/","link":"","permalink":"https://wkmian.github.io/2018/07/12/java-timer/","excerpt":"","text":"今天来聊一聊Java原生的定时器Timer 添加定时任务123456public void schedule(TimerTask task, long delay) ;public void schedule(TimerTask task, Date time);public void schedule(TimerTask task, long delay, long period);public void schedule(TimerTask task, Date firstTime, long period);public void scheduleAtFixedRate(TimerTask task, long delay, long period);public void scheduleAtFixedRate(TimerTask task, Date firstTime,long period); Timer添加定时任务有这六种方式，但其本质上都是调用下面的方法123456/** * @param task 执行任务 * @param time 时间戳 * @param period 延迟毫秒数 大于0小于0区分是 schedule 还是 scheduleAtFixedRate */private void sched(TimerTask task, long time, long period); schedule 与 scheduleAtFixedRate 的区别： schedule 是按照上次任务执行完成的时间点延迟执行，单个任务的执行时长会影响下次任务的执行开始时间。 scheduleAtFixedRate 是按照上次任务的开始时间点计算下次任务的开始时间点，当单个任务执行时间过长会产生并发的问题。 cancel()1public void cancel() 将该定时器内的所有任务全部清空 purge()1public int purge() 将该定时器中的定时任务为 TimerTask.CANCELLED 的TimerTask移出定时器并返回移出数量 最后说明如果TimerTask的首次执行时间小于当前时间会立即执行一次，并不会延迟到下次执行。","categories":[{"name":"编程","slug":"编程","permalink":"https://wkmian.github.io/categories/编程/"}],"tags":[{"name":"java","slug":"java","permalink":"https://wkmian.github.io/tags/java/"}]},{"title":"linux命令","slug":"linux命令","date":"2018-07-03T03:04:06.000Z","updated":"2018-09-11T04:07:51.488Z","comments":true,"path":"2018/07/03/linux-command/","link":"","permalink":"https://wkmian.github.io/2018/07/03/linux-command/","excerpt":"","text":"rm -f","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://wkmian.github.io/tags/linux/"}]},{"title":"第一个博客","slug":"第一个博客","date":"2018-06-26T07:29:34.000Z","updated":"2018-07-17T07:02:41.518Z","comments":false,"path":"2018/06/26/first-blog/","link":"","permalink":"https://wkmian.github.io/2018/06/26/first-blog/","excerpt":"","text":"这个是我的第一个博客","categories":[],"tags":[]}]}