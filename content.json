{"meta":{"title":"wkmian的博客","subtitle":"IT界的小学生","description":"成长之路","author":"wkmian","url":"https://wkmian.github.io"},"pages":[{"title":"分类","date":"2018-06-26T07:05:18.000Z","updated":"2018-06-26T07:27:38.418Z","comments":true,"path":"categories/index.html","permalink":"https://wkmian.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-06-26T07:14:24.000Z","updated":"2018-06-26T07:27:38.399Z","comments":true,"path":"tags/index.html","permalink":"https://wkmian.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"单点登录","slug":"架构/单点登录","date":"2019-01-17T06:37:55.000Z","updated":"2019-01-22T07:48:04.863Z","comments":true,"path":"2019/01/17/single-sign-on/","link":"","permalink":"https://wkmian.github.io/2019/01/17/single-sign-on/","excerpt":"","text":"更新于 2019年01月22日 这里要说的单点登录并非限制用户只在一个设备上登录的单点登录. 本次将如下介绍单点登录 概念 原理 SSO与OAuth 总结 概念随着企业的发展,用到的系统越来越多,不同模块之间的重复登录,将给用户或者运营人员带来很多不便.由此单点登录就产生了. 一个系统登录,其他系统自动登录(免登录)的技术就是单点登录. 原理在BS架构中,用户输入账号,密码取得服务器的信任,服务器将本次用户的session标记已登录,并将唯一标志写入cookie,每次请求浏览器都会单上cookie(这里\b不详细的讲解cookie,),到此传统的登录就已经完成了. 同域下的单点登录 一般来说, 只有一个域名的企业来说,可以通过二级域名来区分不同的系统. 例如 sso.wkmian.com 作为单点登录的域名. 存在两个其他服务\b, 域名分别是 sys1.wkmian.com , sys2.wkmain.com . \b现在我们只需要在sso.wkmian.com上进行登录并记录\b登录状态,同时向sso.wkmian.com\u001f这个域下写入cookie . 如果此时向要让 sys1.wkmian.com 与 sys2.wkmian.com 都能完成自动登录,则需要解决两个问题. 我们知道cookie是无法跨域的. 登录的cookie的域属性是 sso.wkmian.com , sys1和sys2 请求的时候是带不上的. 不同服务器之间的session是独立不共享的,\bsys1和sys2 是无法获取sso服务器上的session信息. 针对问题1, 我们可以将sso的cookie\b设置成顶级域名\b,即cookie的domain为 wkmian.com . 此时两个sys系统就都可以带上cookie请求. 但是cookie只能设置成自己的子域名或者顶级域名,更多的知识可以查询cookie相关资料. 针对问题2,我们可以利用其他技术来让不同服务器直接的session进行共享 tomcat\b的session共享技术甚至可以利用缓存代替. 到此,同域下的单点登录就完成了. 可以这并不是完美的,如果一个企业是不同的域名呢? 不同域下的单点登录 不同域下就不能使用顶级域名这种技术来实现,原因是cookie不是作用域其他顶级域名下. 这里说一下CAS单点登录流程 上图是标准的CAS流程,流程分析如下.第一个系统 sys 用户请求sys系统, \b由于sys系统需要登录,但是现在尚未登录. 跳转到\bSSO登录系统, 这是用户还是没有登录, 跳转到用户登录页面. 用户填写正确的账号,密码后, \bSSO认证成功, SSO服务器记录用户登录状态,写下当前域的cookie,假设\bcookie为CASTGC 同时SSO并生成一个ST(Service Ticker),然后重定向到sys系统并带上ST sys系统获取ST之后向SSO服务器进行ST验证 ST有效,sys系统的session记录下\b登录状态,并设置sys域\b下的cookie. 第二个系统 sys2 用户请求sys2系统,由于sys2也需用登录 跳转到SSO登录系统,\b此时SSO域的\b是存在CASTGC的cookie,\b\bSSO认证成功,重新生成一个ST2,然后重定向到sys2的系统,ST2作为参数. sys2系统拿到ST2向\bSSO服务器进行ST2的验证. ST2有效,sys2系统的session记录下登录状态,并设置sys2域下的cookie, 这样sys2系统就不需要重新走一遍登录流程,并且session不共享也没有问题. 关于ST的验证是有必要的,不可以省掉,如果省掉,那么用户完全可以伪造一个用户信息从而实现登录. 这是非常危险的. 到此,不同域的CAS单点登录就介绍完了. \bOAuth oauth也是可以实现单点登录的,我们先看看oauth的流程. 微信采用oauth2.0协议,我们以微信为例子 oauth流程要比CAS流程复杂一些,具体分析一下 用户\b访问sys系统,sys提示用户登录. 用户点击微信登录,,跳转到微信登录页面,并带上请求参数appid和backurl. 所有企业都可以与微信对接,所以appid区别是哪个企业. 由微信提供,也就是由OAuth服务提供. 我们与OAuth对接的时候需要在OAuth Servier上注册自己的系统,需要填写应用信息,回调地址等.OAuth会生成appid和appSecret,这两个很重要. OAuth根据appid\b找到sys的注册信息,校验backurl和注册的回调地址是否一致(微信只判断域名是否相同,OAuth可以自己设计),验证失败提示错误信息,成功返回授权页面. 微信弹出授权页面,用户同意授权之后OAuth会生成这个用户对应的code,通过backurl返回sys系统,并\b带上参数code. 这里O\u001dAuth将设置自己域下的cookie. sys得到code之后,带上appid和appSecret参数请求OAuth服务,换区用户token. 得到token之后,再去\bOAuah获取用户信息. sys系统设置session为登录状态,并设置sys域下的cookie SSO与OAuth\b区别SSO和OAuth都可以实现单点登录,以下列举一下SSO与OAuth的一些区别 SSO是保障\b客户端(sys)的资源安全,OAtuh是保障OAuth Server的资源安全 SSO验证用户有没有权限访问sys服务资源(资源在sys服务上),OAuth是验证OAuth的资源能不能让用户访问(资源在OAuth上). OAuth相比SSO多了一步appid和appSecret的验证过程,\b这两个参数是由双方约定,假设黑客拦截了code, 黑客不知道appid和appSceret所以也无法获取accessToken. 从信任角度来看,OAuth2.0授权服务端和第三方客户端不属于一个互相信任的应用群（通常都不是同一个公司提供的服务），第三方客户端的用户不属于OAuth2.0授权服务端的官方用户;而单点登录的服务端和接入的客户端都在一个互相信任的应用群（通常是同一个公司提供的服务）,各个子系统的用户属于单点登录服务端的官方用户。 从资源角度来看。OAuth2.0授权主要是让用户自行决定——“我”在OAuth2.0服务提供方的个人资源是否允许第三方应用访问；而单点登录的资源都在客户端这边，单点登录的服务端主要用于登录，以及管理用户在各个子系统的权限信息。 从流程角度来看。OAuth2.0授权的时候，第三方客户端需要拿预先“商量”好的密码去获取Access Token；而单点登录则不需要。 总结单点登录解决同一个浏览器(非两个浏览器)之间的频繁登录的问题,且以上模式都\b只适合B/S架构,C/S架构需要自己调整技术方案(解决cookie的问题).","categories":[],"tags":[]},{"title":"JDK1.7特性","slug":"java/JDK1-7特性","date":"2018-09-19T10:25:15.000Z","updated":"2018-09-22T06:23:35.714Z","comments":true,"path":"2018/09/19/jdk17-features/","link":"","permalink":"https://wkmian.github.io/2018/09/19/jdk17-features/","excerpt":"","text":"更新于 2018年9月19日 JDK 1.7 于2011-07-28发布 主要特性 访问文件系统 Switch 二进制，数字 catch多个异常 实例泛型推断 Try-with-resources Objects Switchswitch 允许使用String类型 ####支持整数类型表示二进制12//默认0b是int类型所以需要强转byte b = byte b = (byte) 0b11101001; // 数字类型的下划线表示 仅能加载连续的数字之间1234567891011 long a = 1234_564_876___45654L; float b = 3.14_159_26f; //error case 错误情况// long c = 123_L;// float d = 3._1412926f;// float e = 3_.1412926f;// int f = 0x_123;// int g = 0_x123;// int h = 654_;// int i = _654; catch 多个异常12345try&#123; doSomething();&#125; catch (IOException | SQLException ex)&#123; throw ex;&#125; 实例泛型推断泛型实例的创建可以通过类型推断来简化 可以去掉后面new部分的泛型类型，只用&lt;&gt;就可以了1List&lt;String&gt; strList = new ArrayList&lt;&gt;(); Try-with-resources 自动关闭资源本质是一个语法糖，实际上还是会调用资源的close函数，所以只有实现AutoCloseable和Closeable接口的对象才会自动调用123try(BufferefReader br = new BufferedReader(new FileReader(path)))&#123; return br.readLine();&#125; java.util.Objects提供九个静态方法 检测对象是否为空，空抛出异常12requireNonNull(T Object)requireNonNull(T Object,String message)","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://wkmian.github.io/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"https://wkmian.github.io/tags/jdk/"}]},{"title":"java编写规范","slug":"java/java编写规范","date":"2018-09-19T05:01:56.000Z","updated":"2018-09-19T09:03:59.542Z","comments":true,"path":"2018/09/19/java-writing-specification/","link":"","permalink":"https://wkmian.github.io/2018/09/19/java-writing-specification/","excerpt":"","text":"更新于 2018年9月19日 总结一些在java里面的一些编写规范 使用缓存缓存数据的时候,尽量不缓存null，而使用其他的类型代替null以区分是没有找到数据还是缓存的数据是null","categories":[{"name":"编程规范","slug":"编程规范","permalink":"https://wkmian.github.io/categories/编程规范/"}],"tags":[{"name":"java","slug":"java","permalink":"https://wkmian.github.io/tags/java/"},{"name":"规范","slug":"规范","permalink":"https://wkmian.github.io/tags/规范/"}]},{"title":"JDK1.8特性","slug":"java/JDK1-8特性","date":"2018-09-10T01:52:18.000Z","updated":"2018-09-22T06:23:35.507Z","comments":true,"path":"2018/09/10/jdk18-features/","link":"","permalink":"https://wkmian.github.io/2018/09/10/jdk18-features/","excerpt":"","text":"更新于 2018年9月19日 JDK 1.8 于2014-03-08发布 主要新特性 Lambda 表达式 方法引用 默认方法 Stream API 函数式编程API Date Time API 加强对日期与时间的处理 Optional Nashorn JavaScript引擎 新工具 Lambda语法如下12(parameters) -&gt; expression(parameters) -&gt; &#123;statements;&#125; lambda表达式重要特征 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值 可选参数圆括号：一个参数无需定义圆括号，但多个参数或无参数需要定义圆括号 可选大括号：如果主体包含一个语句，无需定义大括号 可选return关键字：如果主体只有一个表达式无需声明return关键字，如果定义大括号则需要声明return关键字 lambda表达式使用限制 预定义使用了 @Functional 注释的函数式接口，自带一个抽象函数的方法 SAM（Single Abstract Method 单个抽象方法）类型 lambda变量作用域 在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。 lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义） 方法引用方法引用通过方法的名字来指向一个方法。 方法引用可以使语言的构造更紧凑简洁，减少冗余代码。 方法引用使用一对冒号 :: 。 函数式接口函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口都可以写成lambda表达式，结合lambda使用更方便。 接口默认方法接口可以定义一个默认方法和静态方法 默认方法，让接口可以拥有一个默认实现，防止新增不兼容。感觉这个方法的出现仅仅是为了新JDK兼容而出现了，个人认为在一定程度上破坏了接口的定义。也许它会有更好的用处。123456789public interface Vehicle&#123; default void print()&#123; System.out.println(&quot;我是默认方法&quot;); &#125; static void say()&#123; System.out.println(&quot;我是静态方法&quot;); &#125;&#125; 当多实现接口的时候会出现默认接口冲突1234567public class C implements A,B&#123; @Override public void print()&#123; //重写或者调用接口中的其中一个 A.super.print(); &#125;&#125; Stream API体验一个流式编程编写的统计所有偶数之和代码123List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,10);int count = list.stream().filter(n-&gt; (n&amp;1)==0).mapToInt(i-&gt;i).sum();System.out.println(count); map:在Stream中的意识是映射，就是将当前的value处理成另一个值flatMap：将多个流合成一个流处理 Optional 类可以让java编写时对null的处理方式以流式+lambda的形式更好的展现出来 之前判断null的例子123456789if(null != user)&#123; Address address = user.getAddress(); if(null != address)&#123; Country country = address.Country(); if(null != country)&#123; //TODO &#125; &#125;&#125; ifPresent1234Optional&lt;User&gt; userOptional = Optional.ifNullable(getUser());if(userOptional.isPresent())&#123; //TODO&#125; 虽然ifPresent可以判断value是否存在，但这样的写法没有体现Optional的强大之处，Optional的强大之处在流式编程。下面是利用Optional流式编程的例子12345String result = Optional.ofNullalbe(user) .map(user -&gt; user.getAddress() ) .map(address -&gt; address.getCountry() ) .map(country -&gt; country.getName() ) .orElse(&quot;没有国家&quot;); orElse() orElseGet()对比1234567public T orElse(T other) &#123; return value != null ? value : other;&#125;public T orElseGet(Supplier&lt;? extends T&gt; other) &#123; return value != null ? value : other.get();&#125; 从源代码实现中可以返现，orElseGet只有在对象为空的时候才会去调用other.get()方法执行获取对象操作，Optional.ofNullable(user).orElse(new User()); 这样的写法无论user是否存在都会执行new User(); Nashorn JavaScript从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。 与先前的Rhino实现相比，这带来了2到10倍的性能提升。 jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。 12345$ jjsjjs&gt; print(&quot;Hello, World!&quot;)Hello, World!jjs&gt; quit()&gt;&gt; 日期时间APILocalDate : 本地日期 LocalTime : 本地时间 LocalDateTime : 本地日期时间 ChronoUnit ： 时间单位 Duration ： 时间段 内部记录时间1234567891011121314public final class Duration implements TemporalAmount, Comparable&lt;Duration&gt;, Serializable &#123; /** * The number of seconds in the duration. */ private final long seconds; /** * The number of nanoseconds in the duration, expressed as a fraction of the * number of seconds. This is always positive, and never exceeds 999,999,999. */ private final int nanos;&#125; Temporal.plus() Temporal.minus() 增加或者删除一段时间 isLeapYear() 判断是否是闰年 Period.between(LocalDate start ,LocalDate end) 比较两个时间的差值，返回一个Period对象 Base64在JDK1.8中,Base64编码加入到Java类库 Base64提供了三种编码方式 基本 输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。 url 输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。 MIME 输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\\r’并跟随’\\n’作为分割。编码输出最后没有行分割。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://wkmian.github.io/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"https://wkmian.github.io/tags/jdk/"}]},{"title":"JDK版本更新特性","slug":"java/JDK版本更新特性","date":"2018-09-10T01:46:10.000Z","updated":"2018-09-19T09:03:59.744Z","comments":true,"path":"2018/09/10/jdk-version-update-feature/","link":"","permalink":"https://wkmian.github.io/2018/09/10/jdk-version-update-feature/","excerpt":"","text":"","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://wkmian.github.io/tags/java/"},{"name":"jdk","slug":"jdk","permalink":"https://wkmian.github.io/tags/jdk/"}]},{"title":"mysql","slug":"mysql","date":"2018-07-25T07:04:11.000Z","updated":"2018-08-29T06:41:57.647Z","comments":true,"path":"2018/07/25/mysql/","link":"","permalink":"https://wkmian.github.io/2018/07/25/mysql/","excerpt":"","text":"查看事务运行情况（行锁）1select * from information_schema.innodb_trx\\G trx_mysql_thread_id 为线程id 可以使用kill杀死线程","categories":[{"name":"数据库","slug":"数据库","permalink":"https://wkmian.github.io/categories/数据库/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://wkmian.github.io/tags/mysql/"}]},{"title":"二进制运算","slug":"编程/二进制运算","date":"2018-07-19T01:56:09.000Z","updated":"2018-09-22T06:21:01.424Z","comments":true,"path":"2018/07/19/binary-operation/","link":"","permalink":"https://wkmian.github.io/2018/07/19/binary-operation/","excerpt":"","text":"二进制运算 &amp; 与运算n位都是1得1，否则得0 性质：1X &amp; X = X 1X &amp; (1&lt;&lt;N) 取得N位上是否是1 | 或运算n位都是0得0，否则得1 ^ 异或预算n位相同得0，否则得1 性质：123456789100 ^ 0 = 00 ^ 1 = 11 ^ 1 = 01 ^ 0 = 1且有X ^ X = 0X ^ 0 = X根据这两个性质可以得出，1.相同位上存在偶数个1得0,奇数个1得1,0可以不参与计算2.异或满足结合律和交换律 ~ 非运算（一元运算符）0变1,1变0 &lt;&lt; 左移向左移动，低位补0 >> 右移向右移动n位，最高位补符号位（正数补0，负数补1），其他位补0 >>> 无符号右移同右移，但最高位统一补0 位移注意点：位移时如果位移位数大于数据类型长度，会先将位移位数取模计算，否则将产生无意义元算 源码，反码，补码正整数的原码，反码，补码都是本身原码：原码就是符号位加上真值的绝对值。反码：保留符号位，其余取反补码：反码+1 二进制的一些简单应用： X &gt;&gt; 1 整除2，X &gt;&gt; 2 整除4 X &amp; (X-1) 可以去除二进制表示中最后一个1","categories":[{"name":"编程","slug":"编程","permalink":"https://wkmian.github.io/categories/编程/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wkmian.github.io/tags/算法/"},{"name":"二进制","slug":"二进制","permalink":"https://wkmian.github.io/tags/二进制/"}]},{"title":"算法题总结","slug":"算法/算法题总结","date":"2018-07-17T06:22:55.000Z","updated":"2018-09-19T09:04:37.116Z","comments":true,"path":"2018/07/17/summary-of-algorithm-questions/","link":"","permalink":"https://wkmian.github.io/2018/07/17/summary-of-algorithm-questions/","excerpt":"","text":"有15个瓶子，其中最多有一瓶有毒，现在有四只老鼠，喝了有毒的水之后，第二天就会死。如何在第二天就可以判断出哪个瓶子有毒。提示：二进制","categories":[{"name":"编程","slug":"编程","permalink":"https://wkmian.github.io/categories/编程/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://wkmian.github.io/tags/算法/"}]},{"title":"log4j2使用总结","slug":"java/log4j2使用总结","date":"2018-07-17T01:44:10.000Z","updated":"2018-09-19T09:04:57.304Z","comments":true,"path":"2018/07/17/summary-of-log4j2-usage/","link":"","permalink":"https://wkmian.github.io/2018/07/17/summary-of-log4j2-usage/","excerpt":"","text":"lo4j2的总结log4j2不同于log4j","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://wkmian.github.io/tags/java/"},{"name":"log","slug":"log","permalink":"https://wkmian.github.io/tags/log/"},{"name":"log4j2","slug":"log4j2","permalink":"https://wkmian.github.io/tags/log4j2/"}]},{"title":"java定时器Timer","slug":"java/java定时器Timer","date":"2018-07-12T07:51:14.000Z","updated":"2018-09-19T09:03:59.809Z","comments":true,"path":"2018/07/12/java-timer/","link":"","permalink":"https://wkmian.github.io/2018/07/12/java-timer/","excerpt":"","text":"今天来聊一聊Java原生的定时器Timer 添加定时任务123456public void schedule(TimerTask task, long delay) ;public void schedule(TimerTask task, Date time);public void schedule(TimerTask task, long delay, long period);public void schedule(TimerTask task, Date firstTime, long period);public void scheduleAtFixedRate(TimerTask task, long delay, long period);public void scheduleAtFixedRate(TimerTask task, Date firstTime,long period); Timer添加定时任务有这六种方式，但其本质上都是调用下面的方法123456/** * @param task 执行任务 * @param time 时间戳 * @param period 延迟毫秒数 大于0小于0区分是 schedule 还是 scheduleAtFixedRate */private void sched(TimerTask task, long time, long period); schedule 与 scheduleAtFixedRate 的区别： schedule 是按照上次任务执行完成的时间点延迟执行，单个任务的执行时长会影响下次任务的执行开始时间。 scheduleAtFixedRate 是按照上次任务的开始时间点计算下次任务的开始时间点，当单个任务执行时间过长会产生并发的问题。 cancel()1public void cancel() 将该定时器内的所有任务全部清空 purge()1public int purge() 将该定时器中的定时任务为 TimerTask.CANCELLED 的TimerTask移出定时器并返回移出数量 最后说明如果TimerTask的首次执行时间小于当前时间会立即执行一次，并不会延迟到下次执行。","categories":[{"name":"编程","slug":"编程","permalink":"https://wkmian.github.io/categories/编程/"}],"tags":[{"name":"java","slug":"java","permalink":"https://wkmian.github.io/tags/java/"}]},{"title":"linux命令","slug":"linux命令","date":"2018-07-03T03:04:06.000Z","updated":"2018-09-11T04:07:51.488Z","comments":true,"path":"2018/07/03/linux-command/","link":"","permalink":"https://wkmian.github.io/2018/07/03/linux-command/","excerpt":"","text":"rm -f","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://wkmian.github.io/tags/linux/"}]},{"title":"第一个博客","slug":"第一个博客","date":"2018-06-26T07:29:34.000Z","updated":"2019-01-16T06:22:31.823Z","comments":false,"path":"2018/06/26/first-blog/","link":"","permalink":"https://wkmian.github.io/2018/06/26/first-blog/","excerpt":"","text":"这个是我的第一个博客 哈哈哈","categories":[],"tags":[]}]}