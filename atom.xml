<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wkmian的博客</title>
  
  <subtitle>IT界的小学生</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://wkmian.github.io/"/>
  <updated>2018-09-19T09:03:59.542Z</updated>
  <id>https://wkmian.github.io/</id>
  
  <author>
    <name>wkmian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java编写规范</title>
    <link href="https://wkmian.github.io/2018/09/19/java-writing-specification/"/>
    <id>https://wkmian.github.io/2018/09/19/java-writing-specification/</id>
    <published>2018-09-19T05:01:56.000Z</published>
    <updated>2018-09-19T09:03:59.542Z</updated>
    
    <content type="html"><![CDATA[<p>更新于 2018年9月19日</p><p>总结一些在java里面的一些编写规范</p><ul><li>使用缓存缓存数据的时候,尽量不缓存null，而使用其他的类型代替null以区分是没有找到数据还是缓存的数据是null</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更新于 2018年9月19日&lt;/p&gt;
&lt;p&gt;总结一些在java里面的一些编写规范&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用缓存缓存数据的时候,尽量不缓存null，而使用其他的类型代替null以区分是没有找到数据还是缓存的数据是null&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="编程规范" scheme="https://wkmian.github.io/categories/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="java" scheme="https://wkmian.github.io/tags/java/"/>
    
      <category term="规范" scheme="https://wkmian.github.io/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>JDK1.8更新特性</title>
    <link href="https://wkmian.github.io/2018/09/10/jdk18-update-feature/"/>
    <id>https://wkmian.github.io/2018/09/10/jdk18-update-feature/</id>
    <published>2018-09-10T01:52:18.000Z</published>
    <updated>2018-09-19T09:03:59.542Z</updated>
    
    <content type="html"><![CDATA[<p>更新于 2018年9月19日</p><p>JDK 1.8 于2014-03-08发布<br>主要新特性</p><ul><li>Lambda 表达式</li><li>方法引用</li><li>默认方法</li><li>Stream API 函数式编程API</li><li>Date Time API 加强对日期与时间的处理</li><li>Optional </li><li>Nashorn JavaScript引擎</li><li>新工具</li></ul><h4 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h4><p>语法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">(parameters) -&gt; &#123;statements;&#125;</span><br></pre></td></tr></table></figure></p><p>lambda表达式重要特征</p><ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值</li><li>可选参数圆括号：一个参数无需定义圆括号，但多个参数或无参数需要定义圆括号</li><li>可选大括号：如果主体包含一个语句，无需定义大括号</li><li>可选return关键字：如果主体只有一个表达式无需声明return关键字，如果定义大括号则需要声明return关键字</li></ul><p>lambda表达式使用限制</p><ul><li>预定义使用了 @Functional 注释的函数式接口，自带一个抽象函数的方法</li><li>SAM（Single Abstract Method 单个抽象方法）类型</li></ul><p>lambda变量作用域</p><ul><li>在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。</li><li>lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）</li></ul><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用通过方法的名字来指向一个方法。</p><p>方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p><p>方法引用使用一对冒号 :: 。</p><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口都可以写成lambda表达式，结合lambda使用更方便。</p><h4 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h4><p>接口可以定义一个默认方法和静态方法</p><p>默认方法，让接口可以拥有一个默认实现，防止新增不兼容。感觉这个方法的出现仅仅是为了新JDK兼容而出现了，个人认为在一定程度上破坏了接口的定义。也许它会有更好的用处。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface Vehicle&#123;</span><br><span class="line">    default void print()&#123;</span><br><span class="line">        System.out.println(&quot;我是默认方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static void say()&#123;</span><br><span class="line">        System.out.println(&quot;我是静态方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当多实现接口的时候会出现默认接口冲突<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class C implements A,B&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void print()&#123;</span><br><span class="line">        //重写或者调用接口中的其中一个</span><br><span class="line">        A.super.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h4><p>体验一个流式编程编写的统计所有偶数之和代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(1,2,3,4,5,6,7,8,10);</span><br><span class="line">int count = list.stream().filter(n-&gt; (n&amp;1)==0).mapToInt(i-&gt;i).sum();</span><br><span class="line">System.out.println(count);</span><br></pre></td></tr></table></figure></p><p>map:在Stream中的意识是映射，就是将当前的value处理成另一个值<br>flatMap：将多个流合成一个流处理</p><h4 id="Optional-类"><a href="#Optional-类" class="headerlink" title="Optional 类"></a>Optional 类</h4><p>可以让java编写时对null的处理方式以流式+lambda的形式更好的展现出来</p><p>之前判断null的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if(null != user)&#123;</span><br><span class="line">    Address address = user.getAddress();</span><br><span class="line">    if(null != address)&#123;</span><br><span class="line">        Country country = address.Country();</span><br><span class="line">        if(null != country)&#123;</span><br><span class="line">            //TODO</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ifPresent<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;User&gt; userOptional = Optional.ifNullable(getUser());</span><br><span class="line">if(userOptional.isPresent())&#123;</span><br><span class="line">    //TODO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然ifPresent可以判断value是否存在，但这样的写法没有体现Optional的强大之处，Optional的强大之处在流式编程。下面是利用Optional流式编程的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String result = Optional.ofNullalbe(user)</span><br><span class="line">        .map(user -&gt; user.getAddress() )</span><br><span class="line">        .map(address -&gt; address.getCountry() )</span><br><span class="line">        .map(country -&gt; country.getName() )</span><br><span class="line">        .orElse(&quot;没有国家&quot;);</span><br></pre></td></tr></table></figure></p><p>orElse() orElseGet()对比<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public T orElse(T other) &#123;</span><br><span class="line">    return value != null ? value : other;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public T orElseGet(Supplier&lt;? extends T&gt; other) &#123;</span><br><span class="line">    return value != null ? value : other.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从源代码实现中可以返现，orElseGet只有在对象为空的时候才会去调用other.get()方法执行获取对象操作，Optional.ofNullable(user).orElse(new User()); 这样的写法无论user是否存在都会执行new User();</p><h4 id="Nashorn-JavaScript"><a href="#Nashorn-JavaScript" class="headerlink" title="Nashorn JavaScript"></a>Nashorn JavaScript</h4><p>从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。</p><p>与先前的Rhino实现相比，这带来了2到10倍的性能提升。</p><p>jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ jjs</span><br><span class="line">jjs&gt; print(&quot;Hello, World!&quot;)</span><br><span class="line">Hello, World!</span><br><span class="line">jjs&gt; quit()</span><br><span class="line">&gt;&gt;</span><br></pre></td></tr></table></figure><h4 id="日期时间API"><a href="#日期时间API" class="headerlink" title="日期时间API"></a>日期时间API</h4><p>LocalDate : 本地日期</p><p>LocalTime : 本地时间</p><p>LocalDateTime : 本地日期时间</p><p>ChronoUnit ： 时间单位</p><p>Duration ： 时间段 内部记录时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public final class Duration </span><br><span class="line">        implements TemporalAmount, Comparable&lt;Duration&gt;, Serializable  &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">    * The number of seconds in the duration.</span><br><span class="line">    */</span><br><span class="line">    private final long seconds;</span><br><span class="line">    /**</span><br><span class="line">    * The number of nanoseconds in the duration, expressed as a fraction of the</span><br><span class="line">    * number of seconds. This is always positive, and never exceeds 999,999,999.</span><br><span class="line">    */</span><br><span class="line">    private final int nanos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Temporal.plus() Temporal.minus() 增加或者删除一段时间</p><p>isLeapYear() 判断是否是闰年</p><p>Period.between(LocalDate start ,LocalDate end) 比较两个时间的差值，返回一个Period对象 </p><h4 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h4><p>在JDK1.8中,Base64编码加入到Java类库</p><p>Base64提供了三种编码方式</p><ul><li>基本 输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。</li><li>url 输出映射到一组字符A-Za-z0-9+_，输出是URL和文件。</li><li>MIME 输出隐射到MIME友好格式。输出每行不超过76字符，并且使用’\r’并跟随’\n’作为分割。编码输出最后没有行分割。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;更新于 2018年9月19日&lt;/p&gt;
&lt;p&gt;JDK 1.8 于2014-03-08发布&lt;br&gt;主要新特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lambda 表达式&lt;/li&gt;
&lt;li&gt;方法引用&lt;/li&gt;
&lt;li&gt;默认方法&lt;/li&gt;
&lt;li&gt;Stream API 函数式编程API&lt;/li
      
    
    </summary>
    
    
      <category term="java" scheme="https://wkmian.github.io/tags/java/"/>
    
      <category term="jdk" scheme="https://wkmian.github.io/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>JDK版本更新特性</title>
    <link href="https://wkmian.github.io/2018/09/10/jdk-version-update-feature/"/>
    <id>https://wkmian.github.io/2018/09/10/jdk-version-update-feature/</id>
    <published>2018-09-10T01:46:10.000Z</published>
    <updated>2018-09-19T09:03:59.744Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="java" scheme="https://wkmian.github.io/tags/java/"/>
    
      <category term="jdk" scheme="https://wkmian.github.io/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="https://wkmian.github.io/2018/08/08/red-black-tree/"/>
    <id>https://wkmian.github.io/2018/08/08/red-black-tree/</id>
    <published>2018-08-08T06:13:27.000Z</published>
    <updated>2018-09-19T09:04:37.231Z</updated>
    
    <content type="html"><![CDATA[<p>红黑树是平衡二叉树的一种</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;红黑树是平衡二叉树的一种&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="算法" scheme="https://wkmian.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql</title>
    <link href="https://wkmian.github.io/2018/07/25/mysql/"/>
    <id>https://wkmian.github.io/2018/07/25/mysql/</id>
    <published>2018-07-25T07:04:11.000Z</published>
    <updated>2018-08-29T06:41:57.647Z</updated>
    
    <content type="html"><![CDATA[<p>查看事务运行情况（行锁）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.innodb_trx\G</span><br></pre></td></tr></table></figure></p><p>trx_mysql_thread_id 为线程id 可以使用kill杀死线程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;查看事务运行情况（行锁）&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;c
      
    
    </summary>
    
      <category term="数据库" scheme="https://wkmian.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://wkmian.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>二进制运算</title>
    <link href="https://wkmian.github.io/2018/07/19/binary-operation/"/>
    <id>https://wkmian.github.io/2018/07/19/binary-operation/</id>
    <published>2018-07-19T01:56:09.000Z</published>
    <updated>2018-09-19T09:05:22.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二进制运算"><a href="#二进制运算" class="headerlink" title="二进制运算"></a>二进制运算</h3><ul><li>&amp; 与运算<br>n位都是1得1，否则得0</li></ul><p>性质：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X &amp; X = X</span><br></pre></td></tr></table></figure></p><ul><li><p>| 或运算<br>n位都是0得0，否则得1</p></li><li><p>^ 异或预算<br>n位相同得0，否则得1</p></li></ul><p>性质：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0 ^ 0 = 0</span><br><span class="line">0 ^ 1 = 1</span><br><span class="line">1 ^ 1 = 0</span><br><span class="line">1 ^ 0 = 1</span><br><span class="line">且有</span><br><span class="line">X ^ X = 0</span><br><span class="line">X ^ 0 = X</span><br><span class="line">根据这两个性质可以得出，</span><br><span class="line">1.相同位上存在偶数个1得0,奇数个1得1,0可以不参与计算</span><br><span class="line">2.异或满足结合律和交换律</span><br></pre></td></tr></table></figure></p><ul><li><p>~ 非运算（一元运算符）<br>0变1,1变0</p></li><li><p>&lt;&lt; 左移<br>向左移动，低位补0</p></li><li><p>>> 右移<br>向右移动n位，最高位补符号位（正数补0，负数补1），其他位补0</p></li><li><p>>>> 无符号右移<br>同右移，但最高位统一补0</p></li></ul><h4 id="位移注意点："><a href="#位移注意点：" class="headerlink" title="位移注意点："></a>位移注意点：</h4><p>位移时如果位移位数大于数据类型长度，会先将位移位数取模计算，否则将产生无意义元算</p><h4 id="源码，反码，补码"><a href="#源码，反码，补码" class="headerlink" title="源码，反码，补码"></a>源码，反码，补码</h4><p>正整数的原码，反码，补码都是本身<br>原码：原码就是符号位加上真值的绝对值。<br>反码：保留符号位，其余取反<br>补码：反码+1  </p><h4 id="二进制的一些简单应用："><a href="#二进制的一些简单应用：" class="headerlink" title="二进制的一些简单应用："></a>二进制的一些简单应用：</h4><ul><li>X &gt;&gt; 1 整除2，X &gt;&gt; 2 整除4</li><li>X &amp; (X-1) 可以去除二进制表示中最后一个1</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;二进制运算&quot;&gt;&lt;a href=&quot;#二进制运算&quot; class=&quot;headerlink&quot; title=&quot;二进制运算&quot;&gt;&lt;/a&gt;二进制运算&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&amp;amp; 与运算&lt;br&gt;n位都是1得1，否则得0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性质：&lt;br&gt;&lt;figu
      
    
    </summary>
    
      <category term="编程" scheme="https://wkmian.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://wkmian.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二进制" scheme="https://wkmian.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>算法题总结</title>
    <link href="https://wkmian.github.io/2018/07/17/summary-of-algorithm-questions/"/>
    <id>https://wkmian.github.io/2018/07/17/summary-of-algorithm-questions/</id>
    <published>2018-07-17T06:22:55.000Z</published>
    <updated>2018-09-19T09:04:37.116Z</updated>
    
    <content type="html"><![CDATA[<ul><li>有15个瓶子，其中最多有一瓶有毒，现在有四只老鼠，喝了有毒的水之后，第二天就会死。如何在第二天就可以判断出哪个瓶子有毒。提示：二进制</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;有15个瓶子，其中最多有一瓶有毒，现在有四只老鼠，喝了有毒的水之后，第二天就会死。如何在第二天就可以判断出哪个瓶子有毒。提示：二进制&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
      <category term="编程" scheme="https://wkmian.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://wkmian.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>log4j2使用总结</title>
    <link href="https://wkmian.github.io/2018/07/17/summary-of-log4j2-usage/"/>
    <id>https://wkmian.github.io/2018/07/17/summary-of-log4j2-usage/</id>
    <published>2018-07-17T01:44:10.000Z</published>
    <updated>2018-09-19T09:04:57.304Z</updated>
    
    <content type="html"><![CDATA[<h4 id="lo4j2的总结"><a href="#lo4j2的总结" class="headerlink" title="lo4j2的总结"></a>lo4j2的总结</h4><p>log4j2不同于log4j</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;lo4j2的总结&quot;&gt;&lt;a href=&quot;#lo4j2的总结&quot; class=&quot;headerlink&quot; title=&quot;lo4j2的总结&quot;&gt;&lt;/a&gt;lo4j2的总结&lt;/h4&gt;&lt;p&gt;log4j2不同于log4j&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="java" scheme="https://wkmian.github.io/tags/java/"/>
    
      <category term="log" scheme="https://wkmian.github.io/tags/log/"/>
    
      <category term="log4j2" scheme="https://wkmian.github.io/tags/log4j2/"/>
    
  </entry>
  
  <entry>
    <title>java定时器Timer</title>
    <link href="https://wkmian.github.io/2018/07/12/java-timer/"/>
    <id>https://wkmian.github.io/2018/07/12/java-timer/</id>
    <published>2018-07-12T07:51:14.000Z</published>
    <updated>2018-09-19T09:03:59.809Z</updated>
    
    <content type="html"><![CDATA[<p>今天来聊一聊Java原生的定时器Timer</p><h4 id="添加定时任务"><a href="#添加定时任务" class="headerlink" title="添加定时任务"></a>添加定时任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void schedule(TimerTask task, long delay) ;</span><br><span class="line">public void schedule(TimerTask task, Date time);</span><br><span class="line">public void schedule(TimerTask task, long delay, long period);</span><br><span class="line">public void schedule(TimerTask task, Date firstTime, long period);</span><br><span class="line">public void scheduleAtFixedRate(TimerTask task, long delay, long period);</span><br><span class="line">public void scheduleAtFixedRate(TimerTask task, Date firstTime,long period);</span><br></pre></td></tr></table></figure><p>Timer添加定时任务有这六种方式，但其本质上都是调用下面的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param task 执行任务</span><br><span class="line"> * @param time 时间戳</span><br><span class="line"> * @param period 延迟毫秒数 大于0小于0区分是 schedule 还是 scheduleAtFixedRate</span><br><span class="line"> */</span><br><span class="line">private void sched(TimerTask task, long time, long period);</span><br></pre></td></tr></table></figure></p><hr><h4 id="schedule-与-scheduleAtFixedRate-的区别："><a href="#schedule-与-scheduleAtFixedRate-的区别：" class="headerlink" title="schedule 与 scheduleAtFixedRate 的区别："></a>schedule 与 scheduleAtFixedRate 的区别：</h4><ul><li>schedule 是按照上次任务执行完成的时间点延迟执行，单个任务的执行时长会影响下次任务的执行开始时间。</li><li>scheduleAtFixedRate 是按照上次任务的开始时间点计算下次任务的开始时间点，当单个任务执行时间过长会产生并发的问题。</li></ul><hr><h4 id="cancel"><a href="#cancel" class="headerlink" title="cancel()"></a>cancel()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void cancel()</span><br></pre></td></tr></table></figure><p>将该定时器内的所有任务全部清空</p><hr><h4 id="purge"><a href="#purge" class="headerlink" title="purge()"></a>purge()</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public int purge()</span><br></pre></td></tr></table></figure><p>将该定时器中的定时任务为 TimerTask.CANCELLED 的TimerTask移出定时器并返回移出数量</p><hr><h4 id="最后说明"><a href="#最后说明" class="headerlink" title="最后说明"></a>最后说明</h4><p>如果TimerTask的首次执行时间小于当前时间会立即执行一次，并不会延迟到下次执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天来聊一聊Java原生的定时器Timer&lt;/p&gt;
&lt;h4 id=&quot;添加定时任务&quot;&gt;&lt;a href=&quot;#添加定时任务&quot; class=&quot;headerlink&quot; title=&quot;添加定时任务&quot;&gt;&lt;/a&gt;添加定时任务&lt;/h4&gt;&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="编程" scheme="https://wkmian.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://wkmian.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>linux命令</title>
    <link href="https://wkmian.github.io/2018/07/03/linux-command/"/>
    <id>https://wkmian.github.io/2018/07/03/linux-command/</id>
    <published>2018-07-03T03:04:06.000Z</published>
    <updated>2018-09-11T04:07:51.488Z</updated>
    
    <content type="html"><![CDATA[<pre><code>rm -f</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;rm -f
&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
    
      <category term="linux" scheme="https://wkmian.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>第一个博客</title>
    <link href="https://wkmian.github.io/2018/06/26/first-blog/"/>
    <id>https://wkmian.github.io/2018/06/26/first-blog/</id>
    <published>2018-06-26T07:29:34.000Z</published>
    <updated>2018-07-17T07:02:41.518Z</updated>
    
    <content type="html"><![CDATA[<p>这个是我的第一个博客</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个是我的第一个博客&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
